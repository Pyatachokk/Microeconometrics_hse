#Потанин Богдан Станиславович
#Микроэконометрика
#Семинар №0
#Знакомство с R :)
#-----------------------------------
#РАЗДЕЛ №0. КОМПИЛЯЦИЯ
#-----------------------------------
########
#Чтобы скомпилировать строку в R, достаточно поставить на неё курсор
#и нажать одновременно клавиши ctrl и enter
#Чтобы скомпилировать часть текста в R, достаточно выделить его
#и нажать одновременно клавиши ctrl и enter
#Скомпилируем следующую строку, а затем только 2*8
1 + 2 * 8
  #ЗАДАНИЯ
    #1. Скомилируйте строку, в которой написано 3+5^2
    #2. Скомпилируйте часть строки 3+5^2, в которой осуществляется
    #опперация возведения в квадрат
    #3. Напишите собственную строку и скомпилируйте её
#Чтобы увеличить или уменьшить размер текста в программе, достаточно
#нажать ctrl и + или ctrl и - соответственно.
#-----------------------------------
#РАЗДЕЛ №1. СОЗДАНИЕ ПЕРЕМЕННЫХ
#-----------------------------------
#Создадим переменную x и присвоим ей значение 8
#при помощи оператора присваивания <-
x <- 8
#Также, вместо <- можно использовать =
x = 8
#Посмотрим на значение созданной переменной
x
#Переменные можно называть практически как угодно, используя английские буквы
#Если вы создаете новую переменную с тем же именем, то,
#на самом деле, вы просто переписываете значение старой переменной
x <- 10   #присвоим новое значение переменной x
x         #убедимся, что значение перемнной x изменилось
#Произведем над созданной переменной различные арифметические операции
x ^ 2       #возведем в квадрат
sqrt(x)     #извлечем квадратный корень
x * 3       #умножим на 3
x / 5       #поделим на 5
#Обратим внимание, что произведенные преобразования не изменили
#значение переменной x
x
#Создадим новую переменную используя значение старой
y <- exp(x) + sqrt(x) * log(x)
#Посмотрим на значение новой переменной
y
  #ЗАДАНИЯ
    #1. Найдите синус y используя функцию sin()
    #2. Найдите сумму переменных x и y
    #3. Создайте новую переменную z и присвойте ей значение
    #произведения x и y
    #4. Присвойте переменной y новое значение и убедитесь, что
    #значение переменной z не изменилось
    #5. Создайте переменную dobro и присвойте ей значение
    #суммы переменных x, y и z
    #6. Присвойте y значение exp(x)+sqrt(x) скомпилировав
    #только часть строки
#-----------------------------------
#РАЗДЕЛ №2. ТИПЫ ПЕРЕМЕННЫХ
#-----------------------------------
#Узнаем тип переменной x
typeof(x)   #тип double означает, что мы работаем с вещественным числом
#Создадим текстовую переменную
s<-"Dobro Znanie"
typeof(s)   #тип character означает, что мы работаем со строкой
#Со строковыми переменными нельзя производить арифметические операции,
#поэтому при компиляции следующей строки возникнет ошибка
s * 3
#Строкой может быть и число
s_number <- "100"
#Убедимся, что со строкой по прежнему нельзя производить
#арифметические операции
s_number / 10
#Чтобы поделить s_number на 10, данную переменную следует предварительно
#преобразовать в число, что можно сделать двумя способами
#Во-первых, можно преобразовать её в число временно, лишь для данной операции
as.double(s_number) / 10   #функция as.double() преобразует переменную в double
s_number / 10              #мы получили ошибку, так как s_number до сих является строкой, так как 
                           #мы не переписали саму переменную, а лишь создали её временную
                           #компию, преобразованную в число
typeof(s_number)           #видим, что тип по прежнему character
#Во-вторых, можно переписать значение переменной, сделав её double
s_number <- as.double(s_number)
s_number / 10              #ошибки нет, так как мы перезаписали переменную
typeof(s_number)           #теперь переменная имеет тип double
#Аналогичным образом численные переменные преобразуется в строковые
s_number <- as.character(s_number)
typeof(s_number)           #опять получаем character
  #ЗАДАНИЯ
    #1. Создайте строковую переменную, состояющую из вашего имени и фамилии
    #2. Создайте числовую переменную x и присвойте её значение 18
    #3. Преобразуйте переменную x в строковую используя функцию as.character() и
    #   запишите полученное значение в переменную y
    #4. Возведите переменную y в квадрат, предварительно конвертировав её
    #обратно в double
    #5. Создайте строковую переменную "sin(5)" и убедитесь,
    #что её нельзя преобразовать в число
#-----------------------------------
#РАЗДЕЛ №3. ВЕКТОРЫ
#-----------------------------------
#Создадим вектор v_1, используя функцию c()
v_1 <- c(1, 5, 7)   #убедитесь, что "c" написано в английской раскладке
#Убедимся, что наш вектор v содержит значения 1, 5 и 7
v_1
#С векторами можно производить обычные операции
v_1 * 3
exp(v_1)
#По умолчанию, R производит операции над каждым элементом вектора
#Векторы можно складывать, умножать друг на друга и т.д., если они имеют
#одинаковое количество элементов
#Все операции с векторами, включая умножение, осуществляются ПОЭЛЕМЕНТНО,
#а не как в классической математике
v_2 <- c(10, 30, -5)
v_1 * v_2
exp(v_1) + sin(v_2)
log(v_1 + sin(v_2))
#Количество элементов вектора можно найти следующим образом
length(v_1)
#Векторы можно объединять
c(v_1, v_2)
c(v_1 ^ v_2, v_2 - v_1 * exp(v_2 ^ v_1))
c(v_1 ^ v_2, v_2 - v_1 * exp(v_2 ^ v_1), (v_1 - v_2) * (v_1 + v_2))
#Конкретный элемент вектора можно выбрать, указав его
#порядковый номер в квадратных скобках
v_1[2]     #второй элемент вектора v_1
v_1[2] ^ 5 #математическая опперация над этим элементом
  #ЗАДАНИЯ
    #1. Создайте два вектора xVec и yVec длины 5, содержащие
    #произвольные числа
    #2. Найдите синус произведения этих векторов
    #3. Найдите произведение длин векторов xVec и yVec
    #4. Возведите логарифм суммы ваших векторов в степень суммы их длин
    #5. Создайте третий вектор и присвойте ему значение суммы ваших векторов
    #6. Создайте новый вектор, первая часть которого является суммой трех
    #созданных вами векторов, вторая - их произведением, а третья - суммой длин
    #7. Найдите сумму первого и последнего элементов получившегося вектора
#-----------------------------------
#РАЗДЕЛ №4. ФУНКЦИИ
#-----------------------------------
#Ранее мы уже использовали такие функции, как sin(), typeof(), as.double() и т.д.
#Часто, функции принимают более одно аргумента
#Попробуем рассчитать корреляцию между векторами v_1 и v_2
cor(x = v_1, y = v_2)
#Добавив дополнительный аргумент, мы можем изменить метод
#рассчета корреляции
cor(x = v_1, y = v_2, method = "spearman")
#В функциях не всегда следует указывать все аргументы, так как
#многие их них присваиваются автоматически
#Функции очень легко гуглятся и содержат подробное описание
#Чтобы получить описание функции, используется команда help. Наприме, можно
#посмотреть описание функции следующим образом
help(cor)
#Каждая функция состоит из двух основных частей (сигнатура):
  #1. Аргументы, в примере с корреляцией это x,y, method и, не
  #использовавшийся нами use, вследствие чего было применено его
  #значение по умолчанию
  #2. Возвращаемое значение, в случае с функцией cor - вещественно число (double)
#Создадим функцию самостоятельно, которая возвращает частное векторов, 
#домноженное на какое-то число
some_function <- function (first_vector, second_vector, some_number)
{
  new_vector <- (first_vector / second_vector) * some_number    #создаем новый вектор
  return (new_vector)                                           #возвращаем его как значение функции
}
#Применим созданную функцию к нашим векторам
some_function(first_vector = v_1, second_vector = v_2, some_number = 5)
#Создадим новую переменную и присвоим ей значение функции
some_value <- some_function(first_vector = v_1,second_vector = v_2,some_number = 5)
some_value   #убеждаемся, что переменная содержит значение, возвращенное функцией
#Обратите внимание, что саму функцию, так и её аргументы, при создании
#можно называть практически как угодно. При этом в R нет необходимо заранее указывать
#типы (классы) аргументов функции, поскольку он не является объектно-ориентированным языком
  #ЗАДАНИЯ
    #1. Создайте функцию, которая возвращает сумму двух векторов, деленную на сумму их длин
    #2. Создайте аналогичную функцию для трех векторов
    #3. Используя предыдущую функцию, создайте функцию, которая возвращает возведенную в квадрат 
    #сумму трех векторов, деленную на сумму их длин
#-----------------------------------
#РАЗДЕЛ №5. МАТРИЦЫ
#-----------------------------------
#Матрицы, как правило, создаются из векторов
#при помощи функции matrix(),
#где ncol и nrow указывают на количество строк и столбцов
my_matrix_1 <- matrix(c(1, 5, -5, 3, 9, 10, 3, 2, 90), ncol = 3,nrow = 3)
my_matrix_2 <- matrix(c(3, 19, 8, -20, 3, 15, 6, 17, 33), ncol = 3, nrow = 3)
my_matrix_1   #посмотрем на первую из созданных матриц
my_matrix_2   #посмотрем на вторую из созданных матриц
#При обычном перемножении матрицы умножаются не классическим
#способом, а поэлементно
my_matrix_1 * my_matrix_2
exp(my_matrix_1) + sin(my_matrix_2)
#Классическое умножение матриц осуществляется следующим образом
my_matrix_1 %*% my_matrix_2
#Обратную матрицу можно найти следующим способом
solve(my_matrix_1)
#Чтобы выбрать элемент матрицы, следует написать [номер строки, номер столбца]
my_matrix_1[2, 3]            #элемент из второй строки третьего столбца
exp(my_matrix_1[2, 3] + 5)   #математическая операция над этим элементом
#Чтобы узнать размерность матрицы, можно воспользоваться функцией dim()
dim(my_matrix_1)
dim(my_matrix_1)[1]   #количество строк
dim(my_matrix_1)[2]   #количество столбцов
  #ЗАДАНИЯ
    #1. Убедитесь, что solve(my_matrix_1) является обратной матрицей для my_matrix_1
    #2. Создайте следующую матрицу:
        #2 5
        #8 9
        #3 -10
    #3. Вычислите сумму элементов второго столбца этой матрицы
#-----------------------------------
#РАЗДЕЛ №6. ЦИКЛЫ
#-----------------------------------
#При помощи двоеточия можно создать вектор
#из последовательности чисел
some_seq <- 5:10
some_seq         #убедимся, что мы получили последовательность чисел
                 #от 5 до 10
#Попробуем при помощи цикла найти сумму элементов следующего вектора:
x_vector <- c(1, 6, 3, 7, -15)
n <- length(x_vector)        #сохраним длину вектора
k <- 0                       #сохраним в этой переменной сумму элементов вектроа
#Классический цикл for имеет в R следующий синтаксис
for (i in 1:n)               #параметр i принимает значения от 1 до 5,
{                            #меняющиеся каждую итерацию (шаг) цикла
  k <- k + x_vector[i]       #прибавляем к сумме элементов вектора i-й элемент вектора
}
#Обратите внимание, что если в цикле заменить 1:n на вектор c(1,3,5), то вы
#посчитаете сумму первого, третьего и пятого элементов.
#Сравним полученный нами результат с функцией sum()
k
sum(x_vector)   #эта функция возвращает сумму всех элементов
#Циклы могут быть вложены друг в друга
#Например, найдем сумму элементов следующей матрицы
k_2 <- 0
x_matrix <- matrix(c(1, 5, -5, 3, 9, 10, 3, 2, 90), ncol=3, nrow=3)
n <- dim(x_matrix)[1]
m <- dim(x_matrix)[2]
for(i in 1:n)
{
  for(j in 1:m)
  {
    k_2 <- k_2 + x_matrix[i,j]   #прибавляем к сумме элементов матрицы (i,j)-й элемент вектора
  }
}
#Посмотрим полученное значение и сравним с возвразаемым функцией sum
k_2
sum(x_matrix)
  #ЗАДАНИЯ
    #1. При помощи цикла найдите произведение всех элементов первых
    #двух строк матрицы x_matrix
    #2. Пользуясь циклами, напишите функцию, которая находит произведение элементов
    #двух матриц, не пользуясь %*%. Подсказка: придется использовать три
    #вложенных цикла.
    #3. При помощи циклов напишите функции, которые находят определитель
    #и обратную матрицу
#-----------------------------------
#РАЗДЕЛ №7. ЛОГИЧЕСКИЕ ВЫРАЖЕНИЯ
#-----------------------------------
#Логические выражения это И, ИЛИ, НЕТ и т.д.
#Логические выражения возвращают переменную типа bool
#Которая принимает значения TRUE (правда) и FALSE (ложь)
#Создадим логические переменные, принимающие значения ложь и правда
b_1 <- TRUE
b_2 <- FALSE
!b_1           #убедимся, что не истина возвращает ложь
(b_1 & b_2)    #убедимся, что истина и ложь возвращает ложь
(b_1 | b_2)    #убедимся, что истина или ложь возвращает истина
(b_1 & !b_2)   #убедимся, что истина и не ложь возвращает истина
5 > 7          #возвращает ложь, так как 5<7
5 == 5         #возвращает истину, обратите внимание, что равенство проверяется
               #при помощи ДВУХ РАВНО ==
#Рассмотрим более сложное выражение, возвращающее ложь
b_3 <- ((7 > 5) & (((3 + 5) < 2) | ((5 + 5) == 1 )))
#Выделите отдельно b_3 и нажмите одновременно ctrl
#и enter чтобы увидеть значение этой переменной
#При помощи команды if() можно выполнить часть кода при соблюдении
#определенного условия
#Рассмотрим следующий код изменяя значения k
#Например, при значении 3 код не выполнится,
#а при значении 10 выполнится и напишет "YES!" (убедитесь сами)
k <- 3
if (k >= 5)
{
  print("YES!")   #команда print() пишет в консоле свой аргумент
}
#Также можно определить код, который выполнится, если
#условие не соблюдено
if (k >= 5)
{
  print("YES!")
} else           #else должно быть на одной строке с нижней скобкой if
{
  print("NO!")
}
#Создадим функцию, которая возвращает произведение или сумму двух матриц, если они
#имеют подходящие размерности, и возвращает FALSE - в противном случае
#При этом operation="product" задает значение по умолчанию для аргумента operation
matrix_product <- function (first_matrix, second_matrix, operation="product")
{
  if (dim(first_matrix)[2] == dim(second_matrix)[1])      #если размерности матриц позволяют их перемножать
  {
    if (operation == "product")                           #если производится операция перемножения матриц             
    {
      return (first_matrix %*% second_matrix)             #возвращаем произведение матриц
    } else {                                              #если выполняется другая операция
      if (operation == "sum" & (dim(first_matrix)[1] ==   #если выполняется операция сложения и размерности
                             dim(second_matrix)[2]))      #матриц совпадают
      {
        return (first_matrix + second_matrix)             #возвращаем сумму матриц
      }
    }
  } else {
    return (FALSE)                                        #если размерности матриц не подходят ни для сложения, ни для 
                                                          #произведения, то возвращаем FALSE
  }
}
#Посмотрим, как работает наша функция для различных матриц
#
my_matrix_1 <- matrix(c(1, 5, -5, 3, 9, 10, 3, 2, 90), ncol = 3, nrow = 3)
my_matrix_2 <- matrix(c(3, 19, 8, -20, 3, 15, 6, 17, 33), ncol = 3, nrow = 3)
my_matrix_3 <- matrix(c(3, 19 , 8, -20, 3, 15), ncol = 2, nrow = 3)
my_matrix_4 <- matrix(c(3, 19, 8, -20, 3, 15, 19, -30, 45, 10), ncol = 2, nrow = 5)
#
matrix_product(my_matrix_1,my_matrix_3)                         #возвращает произведение
matrix_product(my_matrix_1,my_matrix_2,operation = "sum")       #возвращает сумму
matrix_product(my_matrix_3,my_matrix_2,operation = "sum")       #возвращает FALSE
matrix_product(my_matrix_1,my_matrix_4,operation = "product")   #возвращает FALSE
  #ЗАДАНИЯ
    #1. Создайте блок if(cond_1=="Ваше Имя" и cond_2=="Ваша Фамилия"), который присваивает
    #значение 10 переменной k_cond, если условие соблюдено, и значение 20 - в противном случае
    #2. Создайте функцию, которая в качестве аргументов принимает два вектора и возвращает их 
    #сумму, если длины векторов совпадают
    #3. В предыдущей функции предусмотрите операции умножения, вычитания и поэлементного перемножения
#-----------------------------------
#РАЗДЕЛ №8. ФРЕЙМЫ
#-----------------------------------
#Дата фрейм похож на матрицу и отличается тем, что столбцы имеют имена
d <- data.frame("Some_Variable"=c(1, 7, 1, -5 ,6), 
                "Other_Variable" = c(10, 3, 5, 15, 32))
#К конкретному столбцу можно обратиться по имени
#при помощи доллара
d$Some_Variable              #получаем значение Some_Variable
d$Other_Variable             #получаем значение Other_Variable
d$Some_Variable[2]           #получаем значение второго элемента Some_Variable
d$Other_Variable[3]          #получаем значение третьего элемента Other_Variable
#Второй способ - по имени
d["Some_Variable"]           #получаем значение Some_Variable
d["Other_Variable"]          #получаем значение Other_Variable
d[2, "Some_Variable"]        #получаем значение второго элемента Some_Variable
d[3, "Other_Variable"]       #получаем значение третьего элемента Other_Variable
#Можно выбрать элементы вектора, матрицы, датафрейма и т.д. исходя из условия
d[,1]                          #выбираем первый столбец
d[2,]                          #выбираем вторую строку
d[(d[,1] > 0 & d[,2] > 0),]    #оставим в dataframe только положительные значения
d[(d[,1] > 0 & d[,2] > 0),2]   #оставим в dataframe только положительные значения и второй столбец
#Можно добавить столбец в dataframe следующими способами
d$New_Column <- c(1, 12, 7, -5 ,100)
d["Other_New_Column"] <- c(10, 32, 3, 590, -100)
#Убедитесь, что в dataframe добавлены два новых столбца
#Над элементами dataframe можно производить обычные операции, включая перезапись значений
d$New_Column <- c(15, 39, -5, -39, -100)                                 #запишем новые значения в New_Column
d$New_Column[d$New_Column < 0] <- d$New_Column[d$New_Column < 0] * (-2)  #домножим все отрицательные значения New_Column на -2
#Убедитесь, что значения d$New_Column изменились
  #ЗАДАНИЯ
    #1. Создайте dataframe, строки которого будут содержать информацию о
    #фильмах (8 строк), а столбцы - о названии, бюджете и продолжительности
    #2. Используя as.matrix() найдите обратную матрицу вашего dataframe
    #3. Добавьте в ваш dataframe информацию о стране выпуска фильма и кассовых сборах
    #4. Всем фильмам, бюджет которых ниже среднего, увеличьте бюджет в 2 раза
    #5. Удалите все фильмы, продолжительность которых больше часа
#-----------------------------------
#Раздел №9. Обращение к элементам векторов, матриц и датафреймаов по логическому вектору
#-----------------------------------
#Рассмотрим способ обращения к элементам вектора
vec_1=c(1, 2, 3, 4, 5)                                 #создаем вектор
vec_bool=c(TRUE, FALSE, TRUE, FALSE, FALSE)            #создаем вектор из bool'ов
vec_1[vec_bool]                                        #выбираем значения vec_1
#для которых vec_bool равен TRUE
vec_2=c(6, 7, 8, 9, 10)                                #другой вектор
(vec_2 > 7)                                            #логическое выражение вернуло вектор bool'ов
vec_1[vec_2 > 7]                                       #выбираем элементы vec_1, для которых
                                                       #соответстующие элементы vec_2 больше 7
#Теперь поработаем с датафреймом
d <- data.frame("Some_Variable"=c(1, 7, 1, -5 ,6), 
                "Other_Variable" = c(10, 3, 5, 15, 32))
#Выберем только те строки, где все значения больше 1
d[(d[,1] > 1) & (d[,2] > 1),]
#Выберем строки в зависимости от условия на вектор
d[vec_2>7,]
d[vec_bool,]
#-----------------------------------
#РАЗДЕЛ №10. Графики и ggplot2
#-----------------------------------
#Загрузим встроенный датафрейм с данными
data(mtcars)
#Посмотрим его описание
help(mtcars)
#Построим простой график зависимости числа лошадиных сил от веса автомобиля
plot(mtcars$hp, mtcars$wt)
#Построим гистрограмму распределения весов автомобиля
hist(mtcars$wt, breaks = 30)
#Воспользуемся библиотекой ggplot2
#Для начала установим и подключим её следующими командами
install.packages("ggplot2")   #устанавливаем (один раз, больше нет необходимости)
library("ggplot2")            #подключаем (каждый раз при начале работы с программой)
#Графики в ggplot2 строятся путем складывания их из различных частей: параметры осей,
#используемые данные, легенда и т.д.
#Построим стильную гистограмму
ggplot(data=mtcars, aes(mtcars$wt)) +                           
geom_histogram(breaks=seq(from = 0,to = 20,by = 0.25),       #by устанавливает ширину шага в гистограмме
  col="deepskyblue3", fill="deepskyblue2", alpha = .5)+      #добавляем красоту
  labs(title="Гистограмма", 
       x="Вес машины", 
       y="Количество наблюдений")+                           #пояснения к графику
  ylim(c(0,6))+xlim(c(1,6))+                                 #устанавливаем границы гарфика по осям
  theme_classic()                                            #устанавливаем тему (в основном влияет на background)
#По аналогии строим ядерную оценку плотности
ggplot(data=mtcars, aes(mtcars$wt)) +                           
  geom_density(col="turquoise4", fill="turquoise3", alpha = .2)+               #добавляем красоту
  labs(title="Ядерная оценка плотности", x="Вес машины", y="Плотность")+       #пояснения к графику
  theme_classic()                                                              #устанавливаем тему (в основном влияет на background)
#Подробней о ggplot2 
#http://r-statistics.co/ggplot2-Tutorial-With-R.html
#https://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html
#-----------------------------------
#РАЗДЕЛ №11*. Использование C++ в R (для самых любопытных и продвинутых)
#-----------------------------------
#Загрузим и подключим необходимые библиотеки
install.packages("Rcpp")              #коннектор R к C++
install.packages("Rcpp11")            #чтобы использовать C++ 11 и старше
install.packages("RcppArmadillo")     #библиотека для быстрой работы с матрицами
library("Rcpp11")
library("RcppArmadillo")
library("Rcpp")
#Рассмотрим обычную линейную регрессию и бутстрапируем оценку ковариационной матрицы оценок
#Для начала симулируем данные
n <- 100000                        #количество наблюдений
x_1 <- rchisq(n,5)                 #симулируем n наблюдений первой независимой переменной
                                   #из хи-квадрат распределения с 5 степенями свободы
x_2 <- runif(n,0,5)                #симулируем n наблюдений первой независимой переменной
                                   #из равномерного распределения от 0 до 5
x_3 <- x_1 + x_2 + rt(n, 5)        #симулируем n наблюдений третьей независимой переменной
                                   #как сумму первой, второй и случайной величины из t распределения
                                   #с 5 степенями свободы
#из равномерного распределения от 0 до 5
sigma <- 3
epsilon <- rnorm(n, 0, sigma)      #симулируем n случайных ошибок из нормального распределения
                                   #с математическим ожиданием 0 и дисперсией sigma
beta_0 <- 1                        #константа
beta_1 <- 2                        #коэффициент при первой независимой переменной
beta_2 <- 3                        #коэффициент при второй независимой переменной
beta_3 <- -1                       #коэффициент при третьей независимой переменной
y <- beta_0 +                      #создаем зависимую переменную
     beta_1 * x_1 +       
     beta_2 * x_2 + 
     beta_3 * x_3 + epsilon            
X <- cbind(1, x_1, x_2, x_3)       #создадим матрицу независимых переменных
colnames(X) = c("Intercept", "X1", "X2", "X3")
#Для начала напишем функцию для бустрапа в R
bootstrap_R <- function(X, y, bootstrap_iterations = 100)
{
  n <- dim(X)[1]                               #сохраняем количество наблюдений
  m <- dim(X)[2]                               #сохраняем количество регрессоров
  #Создадим некоторые векторы заранее, чтобы
  #не тратить на это ресурсы в цикле
  y <- as.matrix(y)
  X_boot = matrix(NA, n, m)
  y_boot = matrix(NA, n, 1)
  B_hat <- matrix(NA, bootstrap_iterations, m)
  sample_ind_bootstrap <- rep(NA, n)
  #Начнем бутстрапировать
  for (i in 1:bootstrap_iterations)            #бустрапируем bootstrap_iterations раз
  {
    sample_ind_bootstrap <- sample(1:n,        #создаем выборку индексов с возвращением
                                   size = n, 
                                   replace = TRUE)
    #Создаем новую выборку, используя выборку из индексов
    X_boot <- X[sample_ind_bootstrap,]            #матрица независимых переменных
    y_boot <- y[sample_ind_bootstrap, 1]          #вектор значений зависимой переменной
    #Оцениваем вектор регрессионных коэффициентов
    B_hat[i,] <- solve(t(X_boot) %*% X_boot) %*% 
                 t(X_boot) %*% y_boot             
  }
  
  return(cov(B_hat))
}
#Оценим ковариационную матрицу оценок регрессионных коэффициентов
#для начала при помощи запрограммированной выше функции
set.seed(123)
t_R <- system.time(results_R <- bootstrap_R(X, y, 200))
results_R
#Сравним с истинной ковариацией оценки и убедимся, что расхождения невелики
results_true = sigma ^ 2 * solve(t(X) %*% X)
results_true
#Теперь воспроизведем данную программу в Rcpp и сравним скорость.
#Скомпилируем в качестве R функции код из файла bootstrap_C.cpp (изучите его содержание).
#Код в этом файле написан на C++. Открыть этот файл можно с помощью R-studio, но
#рекомендую пользоваться Visual Studio 2019, так как там удобный редактор.
#ВАЖНО: желательно поместить bootstrap_C.cpp не в папку, а прямо в корень диска. 
#как в примере ниже. В противном случае может возникать ошибка. Чтобы её не возникало,
#следует организовывать cpp файлы в пакет ,как, например, подробно описано в этой
#инструкции http://web.mit.edu/insong/www/pdf/rpackage_instructions.pdf
Rcpp::sourceCpp(file = "E:\\bootstrap_C.cpp") #долго компилируется, но быстро считает
set.seed(123)
t_C <- system.time(result_C <- bootstrap_C(X, y, 200))
result_C
#Убедимся, что на C++ код выполняется в разы быстрей
data.frame("Время в R" = t_R[3], "Время в C++" = t_C[3], "Отношение" = t_R[3]/t_C[3])
  #ЗАДАНИЯ
    #1. Напишите функцию, рассчитывающую значение функции плотности нормального
    #   распределения в точке x при заданных значениях математического ожидания mean
    #   и стандартного отклонения sigma. Придумайте, как сравнить производительность вашей
    #   функции с функцией dnorm().
    #2. Векторизуйте аргументы предыдущей функции, чтобы, например, она позволяла рассчитать
    #   значения как dnorm(x = c(1,2,3), mean = c(0.1,0.2,0.3), sd = c(3,2,1)).
    #3. Напишите функцию, которая осуществляет расчет RMSE при leave-one-out
    #   кросс-валидации для модели линейной регрессии. На вход подаются матрица
    #   независимых переменных X и вектор значений зависимой переменной y. 
    #   Функция возвращает вещественное число (float или double), равное квадратному 
    #   корню средне-квадратической ошибки предсказания.
    #4. Добавьте в предыдущую функцию аргумент compare (bool) со значением по умолчанию TRUE.
    #   Если данный аргумент равен TRUE, то функция должна, на основе leave-one-out кросс-валидации,
    #   выбрать оптимальный набор регрессоров из X и вернуть их в виде вектора (NumericVector) соответствующих
    #   им индексов.
    #5. Добавьте в данную функцию аргумент k (int), позволяющий осществлять выбор оптимального
    #   набора регрессоров из X на основе k-fold кросс-валидации.
#http://adv-r.had.co.nz/Rcpp.html туториал
#https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-quickref.pdf подробный гид
#https://teuder.github.io/rcpp4everyone_en/index.html манул по Rcpp
#http://arma.sourceforge.net/docs.html мануал по Armadillo
#https://cran.r-project.org/web/packages/Rcpp/index.html ссылка на сборник очень подробных вигнетов
#-----------------------------------
#МАТЕРИАЛЫ ДЛЯ САМОСТОЯТЕЛЬНОГО ИЗУЧЕНИЯ
#-----------------------------------
#0. Все, что касается R, очень легко гуглится, поэтому изучить его можно
#и не пользуясь никакими обучалками, по мере практического использования
#1. Материалы Бориса Борисовича Демешева https://bdemeshev.github.io/r_cycle/
#2. Курс по R на datacamp https://www.datacamp.com/
#3. Беслпатные курсы на coursera, включая
    #2.1. Демешев Борис Борисович https://ru.coursera.org/learn/ekonometrika
    #2.2. Классика от института Хопкинса https://ru.coursera.org/learn/r-programming
    #2.3. С упором на статистику https://ru.coursera.org/specializations/statistics
    #2.4. Продолжение курса от института Хопкинса https://ru.coursera.org/learn/advanced-r
#4. Бесплатные курсы от edex https://www.edx.org/learn/r-programming
#5. Сборники задач по R:
    #4.1. Борзых Д. А., Демешев Б. Б. Эконометрика в задачах и упражнениях. 
    #Издание 2. М. : Издательская группа URSS, 2017
    #4.2. https://www.r-exercises.com/
#6. Видео на youtube:
    #5.1. https://www.youtube.com/watch?v=32o0DnuRjfg
    #5.2. https://www.youtube.com/watch?v=fDRa82lxzaU
#7. Подробные обзоры и гайды по R пакетам можно найти в R-journal
#   https://journal.r-project.org/archive/